
\makeatletter
\@ifundefined{standalonetrue}{\newif\ifstandalone}{}
\@ifundefined{section}{\standalonetrue}{\standalonefalse}
\makeatother
\ifstandalone
\documentclass{report}

\input{all_usepackages} 
\usepackage[margin=1.25in]{geometry}
\usepackage{xcolor}

% Sepia
%\definecolor{myBGcolor}{HTML}{F6F0D6}
%\definecolor{myTextcolor}{HTML}{4F452C}

\definecolor{myBGcolor}{HTML}{3E3535}
\definecolor{myTextcolor}{HTML}{CFECEC}
\pagecolor{myBGcolor}
\color{myTextcolor}

\begin{document}
\fi

{ \graphicspath{{rbffd_methods_content/}} 





\subsection{Time Stepping}

Until now we have assumed that the differential operator $\diffop{}$ had no time dependency. However, many important problems are a function of time: 
\begin{eqnarray}
\pd{u(x;t)}{t} &=& \diffop{u(x;t)} \\
\boundop(u(x;t)) &=& g(x) 
\label{eqn:timedep}
\end{eqnarray}
with some initial condition $u(x;0) = f(x)$. Both collocation methods and RBF-FD methods can be used to discretize the right hand side. In the case of collocation, the coefficients $c$ are now functions of time. On the other hand, it is the unknown functional values that are considered to be the unknown, time-dependent variables when RBF-FD is used. 	

The general approach for collocation methods is to first use the initial and boundary conditions to get an initial set of 
coefficients $c(t), d(t)$, whereas before, $(c,d)$ denotes the list of unknown coefficients of the RBF basis functions and the monomials. 
%If the RBF centers and collocation points are stationary (either because the PDE is a boundary value problem or a non-moving node initial value problem) 
Prior to spatial discretization, Equation~\ref{eqn:timedep} is updated using any of the standard methods for time-stepping, such as Euler, Crank-Nicholson, or higher order Runge-Kutta methods to name a few. Here we demonstrate the approach with the Euler method (which is explicit) for simplicity. In practice, a higher order method would be chosen, perhaps an implicit method. 
The Euler method can be written as
\begin{eqnarray}
u(x; t_{n+1}) &=& u(x; t_{n}) + \Delta t (\diffop{u(x;t_n)}) %\\
 %&=& u(x; t_{n}) + \Delta t ( A_\diffop{} A^{-1} u(x;t_n))
 \label{eqn:euler_time}
\end{eqnarray}
%\toevan{Please make sure notation of previous line is correct. Use same notation $A_\diffop{} A^{-1}$.}
Since $u(x;0)=u(x;t_0)$ is known as a function of $(c,d)=A^{-1} u(x;t_n)$, it is straightforward to compute the coefficients, and from there, $\diffop(u(x;t_n))$. 

Equation~\ref{eqn:euler_time} is solved via a two step algorithm: 
\begin{enumerate}
	\item solve Equation~\ref{eqn:solve_rbf} to approximate $\diffop{u(x;t_n)}$ for the current time-step
	\item update $u(x;t_{n+1})$
\end{enumerate}
Initially, $A_\diffop{} A^{-1}$ is computed once during the first time-step, and the first part of the algorithm is reduced to an inner product to get $\diffop{u(x;t_n)}$. Once $u(x;t_{n+1})$ is updated, one repeats the procedure with $u(x;t_{n+1})$ as a new initial condition. For collocation methods, one must recompute all the coefficients at each timestep (i.e. recompute $A^{-1}$), which is expensive. On the other hand, for a static grid,  $A_\diffop{} A^{-1}$ can be precomputed and there is no longer any need to work in coefficient space. In this case, we have a type of RBF-FD method, which is solely expressed in terms of functional values. Of course, in a "pure" RBF-FD method, one has expressions for the various derivatives and operators as a linear combination of functional values (the derived stencil being an implicit function of the RBFs and their location). 

There is a huge literature on time-stepping schemes for finite-difference, finite-volume, spectral methods, etc., and many of these methods can be adopted to the solve time-dependent problems on meshless grids. Although there are surely issues that are particular to RBFS, we do not discuss them here. Instead, we will include our experiences in the final thesis. 


For initial value problems with moving nodes, the coefficients must be updated at each time-step whether working with collocation or RBF-FD. We do not consider moving node problems in this thesis. 
%
%\section{Coupled Equations}
%In the case of coupled equations (e.g. the shallow water equations)

%\hl{NEED AN EXAMPLE (perhaps solving the heat equation) better yet, lets demonstrate the heat equation in the proposal section when we talki about he existing code and how we plan to extend it.}

%To illustrate, we consider the simple forward Euler case time is discretized as:
%\begin{eqnarray}
%\pd{u(x;t)}{t} = \frac{u_{n+1}(x) - u_{n}(x)}{\Delta t} &=& \diffop{u_{n}(x)} \\
%u_{n+1} &=& u_{n} + \Delta t (\diffop{u_{n}(x)})
%\end{eqnarray}
%Initially, coefficients $c_j$ are found by solving: 
%\begin{eqnarray}
%\diffop{u_1}(x) = f(x) \\

%\end{eqnarray}
%At each time step we know $u_n$ and $\diffop{u_{n}}(x)$ using Equations~\ref{eqn:solve_u} and \ref{eqn:solve_uxx}. Then the time stepping algorithm is two part: 
%\begin{enumerate}
%	\item find interpolant $u_{\phi}(x)$  $\diffop{u_n(x)} using collocation or RBF-FD
%	\item a
%\end{enumerate}
%
%\section{RBF-FD Example: Solving a Time-Dependent PDE}
%\toevan{NEED TO FINISH THIS}
%In this section, we provide a small example of how to solve a time-dependent elliptic PDE (the heat equation) using RBF-FD. 

%We start with the equation:
%\begin{eqnarray}
%\pd{u(x,y;t)}{t} &=&  k \nabla^{2} u(x,y;t) \on{\Interior} \\
%u(x,y;t) &=& 0 \hskip5em\on{\Boundary}
%\end{eqnarray}

%To simplify notation we let $\vec{u}_n = u(x,y; t_n) = [u_{n,x}\ \ u_{n,y}]^T$ where the subscript $u_{n,x}$ specifies the $x$ component of $u_n$.

%We start by solving for $\nabla^2 \vec{u}_n$ using RBF-FD: 

%\begin{eqnarray}
%u^{(k)}_\phi(x) = \sum_{j(k)=1}^{N_S} c^{(k)}_j \phi_j(x) + \sum_{l(k)=1}^{M} d^{(k)}_l P_l(x) &\approx& u(x)
%\end{eqnarray}


%Using 4th-Order Runge-Kutta (\cite{Burden2005}) for time discretization: 
%\begin{eqnarray}
%\vec{k_1} &=& \Delta t (\nabla^{2} \vec{u_n}) \\
%\vec{k_2} &=& \Delta t (\nabla^{2} u_{n+}(x+k_{1,x}/2,y+k_{1,y}/2; t)) 
%\end{eqnarray}



%
%We discretize to get: 
%\begin{eqnarray}
%\vec{u'} & = & \phi \vec{b} \\
%&=& 
%\end{eqnarray}

%An alternate form in which we can express our problem is by expanding $\nabla^2$: 
%\begin{equation}
%\frac{du(x)}{dt} = \nabla \cdot \nabla u(x)
%\end{equation}
%which allows us to reformulate the approximate solution as a two part algorithm: 
%\begin{eqnarray}
%v(x) &=& \nabla u(x) \\
%\frac{d u(x)}{dt} &=& \nabla \cdot v(x)
%\end{eqnarray}

%%\hl{start fresh here: }

%%These notes are based on \cite{Fasshauer:2007}.

%%To apply radial basis functions to the solution of PDEs, we assume we assume we are given a domain $\Omega \subset \R^s$, 
%%and a linear elliptic PDE of the form: 
%%\begin{eqnarray}
%%L u(x) &=& f(x), \ \ \ \ \ \ \ x \textrm{ in } \Omega\\
%%u(x) &=& g(x), \ \ \ \ \ \ \ x \textrm{ on } \partial \Omega
%%\end{eqnarray}
%%where $L$ is some operator (i.e. $\nabla^2$). 

%%\hl{collocation} We then use Kansa's collocation method to express the solution 

%%\hl{Show how the laplacian is expressed in terms of $\phi_0 '$ times original RBF}
%%\begin{eqnarray}
%%Lu(x_i) &=& \sum_{j(i)=1}^{NP} c_j \varphi(\vectornorm{x_i - x_j}) \\
%%c_j &=& 
%%\end{eqnarray}

%%
%%\hl{notes on collocation}
%%This is the collocation formula: 
%%\begin{equation}
%%f(x) = \sum_{j=1}^{N} a_j \varphi(r) + \sum_{j=N+1}^{N + (M-1)} b_j P(x)
%%\end{equation}
%%were the first sum is for standard interpolation, and the second sum both enforces that our residual be: 
%%\begin{equation}
%%\sum_{j=1}^{N} b_j P(x) = 0
%%\end{equation}
%%and also enforces that our polynomial interpolant be order $M-1$. \hl{Is this the "order"?}

%
%For more details on unsymmetric and symmetric collocation, including collocation with compactly supported RBFs, refer to \cite{Fasshauer:2007}.

%If the PDE is time dependent, we let the coefficients $c_j$ be time dependent (i.e., $c_j(t)$) and solve for them at discrete time steps \cite{Mouat:2002}

%To solve the linear systems we use Cholesky, but a conjugate gradient is better for systems that are too large for Cholesky. In our case we have many small matrices so its ok for the former. 

%Multiple levels for decomposition: 1) domain decomposition to reduce conditioning number in global RBF; 2) parallel decomposition to reduce compute time. \cite{Divo:2007} uses 2). 


}

\ifstandalone
\bibliographystyle{plain}
\bibliography{merged_references}
\end{document}
\else
\expandafter\endinput
\fi


